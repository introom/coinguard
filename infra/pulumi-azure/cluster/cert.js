"use strict";

const azure = require("@pulumi/azure-native");
const azure_classic = require("@pulumi/azure");
const azuread = require("@pulumi/azuread");
const k8s = require("@pulumi/kubernetes");

const config = require("./config");
const resource = require("./resource");
const util = require("./util");
const cluster = require("./cluster");
const nginx = require("./nginx");
const zone = require("./zone");

// cert manager chart
// see https://github.com/jetstack/cert-manager/blob/master/deploy/charts/cert-manager/values.yaml
const certManagerName = util.resourceName`cert-manager`;
const certManager = new k8s.helm.v3.Release(
  certManagerName,
  {
    namespace: cluster.namespace.metadata.name,
    repositoryOpts: { repo: "https://charts.jetstack.io" },
    // see https://cert-manager.io/docs/installation/helm/#4-install-cert-manager
    chart: "cert-manager",
    version: "v1.8.0",
    values: {
      global: {
        leaderElection: {
          namespace: cluster.namespace.metadata.name,
        },
      },
      installCRDs: "true",
      // do not expose prometheus metrics
      // see https://cert-manager.io/docs/usage/prometheus-metrics/
      prometheus: { enabled: false },
      // see https://stackoverflow.com/a/66042994/855160
      extraArgs: [
        "--dns01-recursive-nameservers-only",
        "--dns01-recursive-nameservers=1.1.1.1:53,1.0.0.1:53",
        // https://github.com/jetstack/cert-manager/blob/725705cde5f0c155664fd5a6ee4e23627e95a854/deploy/charts/cert-manager/values.yaml#L91
        // remove the secret of a certificate if that certificate itself gets removed
        "--enable-certificate-owner-ref=true",
      ],
    },
  },
  { provider: cluster.provider }
);

// see https://cert-manager.io/docs/concepts/issuer/
// we now create a cluster issuer

// service principal for cert manager
// see https://cert-manager.io/docs/configuration/acme/dns01/azuredns/#service-principal
const spName = util.resourceName`cert-manager`;
const sp = new azuread.ServicePrincipal(spName, {
  applicationId: new azuread.Application(spName, {
    displayName: spName,
  }).applicationId,
});

const spPassword = new azuread.ServicePrincipalPassword(spName, {
  servicePrincipalId: sp.id,
  // password is auto generated by azure
});

// give sp zone auth
const zoneAuth = new azure_classic.authorization.Assignment(spName, {
  principalId: sp.id,
  scope: zone.zone.id,
  roleDefinitionName: "DNS Zone Contributor",
});

// mainly store the sp password to authenticate as the sp
const dnsSecretName = util.resourceName`cert-dns-secret`;
const dnsSecret = new k8s.core.v1.Secret(
  dnsSecretName,
  {
    metadata: {
      name: dnsSecretName,
      namespace: cluster.namespace.metadata.name,
    },
    stringData: {
      "sp-password": spPassword.value,
    },
  },
  { provider: cluster.provider }
);

// this is a promise!
const clientConfig = azure.authorization.getClientConfig();
const certIssuerName = util.resourceName`cert-issuer`;
const certIssuer = new k8s.apiextensions.CustomResource(
  certIssuerName,
  {
    apiVersion: "cert-manager.io/v1",
    kind: "ClusterIssuer",
    metadata: {
      name: certIssuerName,
      namespace: cluster.namespace.metadata.name,
    },
    spec: {
      acme: {
        // see https://cert-manager.io/docs/tutorials/acme/ingress/#step-6-configure-let-s-encrypt-issuer
        // see rate limits of letsencrypt: https://letsencrypt.org/docs/rate-limits/
        server: "https://acme-v02.api.letsencrypt.org/directory",
        email: "frepanda@firepandalabs.com",
        // place to store the secret received from letsencrypt (for the ca).
        // see https://cert-manager.io/docs/reference/api-docs/#:~:text=registered%20ACME%20account.-,privateKeySecretRef,-SecretKeySelector
        privateKeySecretRef: {
          name: util.resourceName`letsencrypt-key`,
        },
        solvers: [
          {
            dns01: {
              azureDNS: {
                clientID: sp.applicationId,
                // login as the sp (so as to access azure dns)
                clientSecretSecretRef: {
                  name: dnsSecret.metadata.name,
                  key: "sp-password",
                },
                subscriptionID: clientConfig.then(
                  (clientConfig) => clientConfig.subscriptionId
                ),
                tenantID: clientConfig.then(
                  (clientConfig) => clientConfig.tenantId
                ),
                // the resouce group that the dns zone is in
                resourceGroupName: resource.resourceGroup.name,
                hostedZoneName: zone.zone.name,
                environment: "AzurePublicCloud",
              },
            },
          },
        ],
      },
    },
  },
  {
    dependsOn: [certManager, dnsSecret],
    provider: cluster.provider,
  }
);

// see https://cert-manager.io/docs/usage/certificate/
const certificateName = util.resourceName`certificate`;
const certificate = new k8s.apiextensions.CustomResource(
  certificateName,
  {
    apiVersion: "cert-manager.io/v1",
    kind: "Certificate",
    metadata: {
      name: certificateName,
      namespace: cluster.namespace.metadata.name,
    },
    spec: {
      // the place to store the certificate and its secrets. 
      // XXX nginx also looks at it!
      secretName: nginx.defaultCertName,
      // get certificate from this issuer
      issuerRef: { name: certIssuer.metadata.name, kind: certIssuer.kind },
      privateKey: { rotationPolicy: "Always" },

      // a single * matches aaa, but not aaa.bbb
      dnsNames: [
        `*.${zone.zoneName}`,
        // XXX per-project
        `*.coinguard.${zone.zoneName}`,
      ],
    },
  },
  {
    provider: cluster.provider,
  }
);
